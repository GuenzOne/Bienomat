/*
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/*,,*(%@@@@@@@@@@@@@@@@@@@@@@@#/.,(##*,/@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&.(%@@@*,*#%&&&%#(/*****(&@@&*,(@@@@@@@(*#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/(@@@@@@@@@@#(//(#%&@@@@@@&*,/,/@@@@@@@@@@/,&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%,#@@@@@@@@@@@@@@@@@@@@@@@@@@%.,@@@@@@@@@@@&/#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%*(@@@@@@@@@@@@@@@@@@@@@@@@@@@/,&@@@@@@@@@@@%(&@@@@@@%(&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/./@@@@@@@@@@@@@@@@@@@@@@@@@@@@#/@@@@@@@@@@@&/%@@@@&/  ,#@@@@@@@@/.#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(.**&@@@@@@@@@@@@@@@@@@@@@@@@@@@@*&@@@@@@@@@@@/%@&(.. .,@@@@@@@@%/.,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,.%@#/&@@@@@@@@@@@@@@@@@@@@@@@@@@@#(&@@@@@@@@@@*(/.  .*&@@@@@@@%,. *%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/,#@@@/*@@@@@@@@@@@@@@@@@@@@@@@@@@@&*(@@@@@@@@@@,  ..#&@@@@@@#/. ./@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&(.&@@@@@#*#@@@@@@@@@@@@@@@@@@@@@@@@@@/*@@@@@@@@@@, .%@@@@@@.  ./@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&..&@@@@@@@*@@@@@@@@@@@@@@@@@@@@@@@@@&/#@@@@@@@@@,,&@@@&/..  .(&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#,/&@@@@@@@@@@&/&@@@@@@@@@@@@@@@@@@@@@@@%/&@@@@@@@&,/@..   ,/@@@@@@&%%%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@% *@@@@@@@@@@@@@@&**%@@@@@@@@@@@@@@@@@@@@@@*(@@@@@@@&,//.   .*#@@@,.      ,/@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@#####################(.(@@@@@@@@@@@@@@@@@@(/#@@@@@@@@@@@@@@@@@@@@**@@@@@@@&,.     ,****,.           ,(@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@%*,(((((((((((((((((((((./%@@@@@@@@@@@@@@@@@@*(@@@@@@@@@@@@@@@@@@#*&@@@@@@@,  ,(%%#,.,/,.           #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@%.*@@@@@@@@@@@@@@@@@@@@@@@* %@@@@@@@@@@@@@@@@@@@@@(*(@@@@@@@@@@@@@@@&((@@@@@@@, .,.  ,&@@@@@@%/.         .#@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@/.#@@@@@@@@@@@@@@@@@@@@@@@@@(./@@@@@@@@@@@@@@@@@@@@@@%/@@@@@@@@@@@@@@%*@@@@@@&.       *#@@@@@@@(          ,#@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@(./@@@@@@@@@@@@@@@@@@@@@@@@@@@/.(@@@@@@@@@@@@@@@@@@@@@@@&/(&@@@@@@@@@@@&,@@@@@&/         ./%@@@@@&,          ,@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@#.%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@% %@@@@@@@@@@@@@@@@@@@@@@@@%/(%@@@@@@@@@&,&@@@&,.,.         .&@@@@@/.         .&@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@/.#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(./@@@@@@@@@@@@@@@@@@@@@@@@@%((@@@@@@@@&.(&&%,%@@@/.        /@@@@@&(         .&@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@%**%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#,*%@@@@@@@@@@@@@@@@@@@@@@@@@/.,%%*.        *&@@@@@%..     .%@@@@@@,        .&@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@&.,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&..&@@@@@@@@@@@@@@@@@@@@@@&(.#*             .*@@@@@%/      .*@@@@@(,      .*@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@./&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/,@@@@@@@@@@@@#/,,*(%@@@, *,.               *%@@@@&,       (&@@@@%.    .(&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@%*,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@, ...........        ..  .&@*. ..          .*@@@@@%.      ,#@@@@@,   .#@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@#.%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@% #&@@@@@@@%@@@@@@@@@&, ,@@&/.             .#@@@@@*.     ./@@@@&.  ,(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@%.,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@, %@@@@@@@@@@@@@@@@@@@@,   .&@@@&.             .&@@@@(,      .%%(...(%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@#,/&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%*,#@@@@@@@@@@@@@&&@@@@@@*.(&,#@@@&,.             (&@@@/.          .(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@&..&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&..&@@@@@@@@@@@@@@*.,%&@@&.,@@#,#@@@@&.            .,(%&,      .,(. %@@@@@@@@&&%%%%&&@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@%*,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,*%@@@@@@@@@@@@@@@@@@%(**, ,@@@/,%@@&/             .,.    ..**,,/*.(&%(/*,..         ./%@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@,/&@@@@@@@@@@@@@@@@@@@@@@@@@@@%*,@@@@@@@@@@@@@@@@@@@@@@@@&..(&@@%,*@@@(,          *@@%/.&@@@@@@@%,.        .,,((#&@@@&/.*&@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@*.%@@@@@@@@@@@@@@@@@@@@@@@@@# *@@@@@@@@@@@@@@@@@@@@@@@&(*%@@#. ....(#,        ./%@@@@@/&@@@@@@@@@@(*.#&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@(./@@@@@@@@@@@@@@@@@@@@@@@/.(@@@@@@@@@@@@@@@@@@@@@@@&/@@@@@#//#%%,        .(%@@@@@@@&,/@@@@@@@@@@@@@/,., /((#%&@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@/.(@@@@@@@@@@@@@@@@@@@@@(./@@@@@@@@@@@@@@@@@@@@@@@%*#@@@@@@@@@@@@,..*%/.*%@@@@@@@@@@@(,&@@@@@@@@@@@@@@#* .,,,,..,*&@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@#                       /&@@@@@@@@@@@@@@@@@@@@@@@%/#@@@@@@@@@@@%/%. ...&@@@@@@@@@@@@@(/%@@@@@@@@@@@@@@@(,(@@@@@*..#@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@#,*@@@@@@@@@@@@@@@@@@@@@% ,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/,#*,#@/*@@@@@@@@@@@@@@@*,&@@@@@@@@@@@@@@@(,/&@@@@@#@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@&(./@@@@@@@@@@@@@@@@@@@@@@@&/.(@@@@@@@@@@@@@@@@@@@@@@@@@@@#.,(%&@@# *@@@/#@@@@@@@@@@@@@@@@@//&@@@@@@@@@@@@@@@*.#@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@,.%@@@@@@@@@@@@@@@@@@@@@@@@@@* %@@@@@@@@@@@@@@@@@@@@@@@@@%*%@@@@@%.#@@@&/%@@@@@@@@@@@@@@@@@@(*(&@@@@@@@@@@@@@&(.&@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@/,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@(.&@@@@@@@@@@@@@@@@@@@@@@@@/,&@@@@(./@@@@&/%@@@@@@@@@@@@@@@@@@@@(,(@@@@@@@@@@@@@@/&@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@&(.&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/.(@@@@@@@@@@@@@@@@@@@@@@@&&@@@@#.*@@@@@&/&@@@@@@@@@@@@@@@@@@@@@@/,(@@@@@@@@@@@@%,(@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@,.%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@* %@@@@@@@@@@@@@@@@@@@@@@@@@@@*.#@@@@@@%/&@@@@@@@@@@@@@@@@@@@@@@@#**#@@@@@@@@@@&,/@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@%*,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#./@@@@@@@@@@@@@@@@@@@@@@@@@(.(@@@@@@@%(&@@@@@@@@@@@@@@@@@@@@@@@@@(,(@@@@@@@@@&,/@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@%.*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%,*@@@@@@@@@@@@@@@@@@@@@@&/,@@@@@@@@@#(&@@@@@@@@@@@@@@@@@@@@@@@@@@@(,#@@@@@@&,(&@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@&.#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&./#%%%%%%%%%%%%%%%%%%%%..&@@@@@@@@@#*%@@@@@@@@@@@@@@@@@@@@@@@@@@@@*,&@@@&*./@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@&(.&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/.,///////////////////* .&@@@@@@@@@#*%@@@@@@@@@@@@@@@@@@@@@@@@@@@@&(.,/%&@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@*,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@# %@@@@@@@@@@@@@@@@@@@@@%*.&@@@@@@@@#*%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@,,@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@,.%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@* #@@@@@@@@@@@@@@@@@@@@@@@@,,%@@@@@@@#*%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(,&@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@%.,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#,*%@@@@@@@@@@@@@@@@@@@@@@@@@@, #@@@@@@%*&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&*%@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@#,/////(#@@@@@@@@@@@@@@@@@@@@@@@@% ,@@@@@@@@@@@@@@@@@@@@@@@@@@@@&( *@@@@@%*%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%*%@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@&/@@@@@@@#((@@@@@@@@@@@@@@@&&@@@&./&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/./@@@@&*%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/,&@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@%(&@@@@@@@@//@@@@@@@@%(/(%%&%%(*,&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@% (@@@&/%@@@@@@@@@@@@@@@@@@@@@@@@@@@@&(,(@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@/(@@@@@@@@@@/(@@@@%/&@@@@@@@@@@@#/%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@( *@@@/#@@@@@@@@@@@@@@@@@@@@@@@@@,,*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@%/@@@@@@@@@@@@&%%&@@@@@@@@@@@@@@@@%/&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#,,#@(/@@@@@@@@@@@@@@@@@@@@#/*(%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@&(&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&/@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&. ,,,&@@@@@@@@@@@@@@@@#,*%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@#%@@@@@@@@@@@@@@@@@&%%&@@@@@@@@@@@@##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&..%%(#@@@@@@@@@@@@@@/,(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@%(&@//##(/#@@@%(/&@&(#@@@@@@@@@@@@/#@@@@@@@@@@@@@@@@@@@@@@@@@@@@#,/%@@&*(@@@@@@@@@@@#*#&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@&(&&/%@@@@@@&(//%@@@@@@/(@@@@@@@@@@@%/@@@@@@@@@@@@@@@@@@@@@@@@@@@%.,@@@@@%/#@@@@@@@@@#/%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@%#@%#@@@@@@@@@@@@@@@@@@@##@@@@@@@@@@@&(&@@@@@@@@@@@@@@@@@@@@@@@@#.%@@@@@@@@@//#%&&%**&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@#%@%(&@@@@@@@@@@@@@@@@@@@%/#@@@@@@@@@@#/%@@@@@@@@@@@@@@@@@@@@@@*.#@@@@@@@@@@@@&%(##@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@&/&@&/&@@@@@@@@@@@@@@@@@@@@@&(/#@@@@@@@@@%//#%@@@@@@@@@@@@@@@@&(.(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@#/@@@/#@@@@@@@@@@@@@@@@@@@@@@@@@//&@@@@@@@@@@&%((///////(@@@@@,.%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@/(@@@#/@@@@@@@@@@@@@@@@@@@@@@@@@@@//@@@@@@@@@@@@@@@@@@@@@(/@@*,#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@/#@@@@#%@@@@@@@@@@@@@@@@@@@@@@@@@@&(&@@@@@@@@@@@@@@@@@@@@@@/.*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@/%@@@@&(&@@@@@@@@@@@@@@@@@@@@@@@@@&(%@@@@@@@&%%&&@@@@@@@@@@#*&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@/#@@@@&/&@@@@@@@@@@@@@@@@@@@@@@@@@&(%@@@@@//&&@&(/#%&&%//%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@(/@@@@&(&@@@@@@@@@@@@@@@@@@@@@@@@@&(&@@@@##@@@@@@@@@@@&&&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@&/(/&@@@@@@@@@@@@@@@@@@@@@@@@@@%/@@@@@%#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#/@@@@@@/%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%/@@@@@@/%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%(@@@@&/&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#////(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



QUELLCODE DES BIENOMATEN 1.0

2019

--------------------------------
|Eine Projektarbeit von:        |
--------------------------------
|Maximilian Döring              |
|                               |
|David Saric                    |
|                               |
|Frederic von Rüden             |
--------------------------------
*/
#include <WiFi.h>
#include "HX711.h"
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>
#include "SHT21.h"
#include <Preferences.h>
#include "esp_system.h"

#include <lvgl.h>
#include <Ticker.h>
#include <TFT_eSPI.h>

#define TINY_GSM_MODEM_SIM800
#include <TinyGsmClient.h>
#include <HTTPClient.h>

#define ConversionSeconds 1000000  // Conversion factor for micro seconds to seconds //
#define SleepTime 30              //  Time ESP32 will go to sleep (in seconds) 

#define Threshold 35  //Sensivity for Touch GPIO Wakeup (Greater the value, more the sensitivity)
bool Touch = false;   // Variable for touchwakeup
touch_pad_t touchPin; //sets touchpin as trigger for touchwakeup

#define BME_SCL 22                       // Pin Define BME280 and GY21
#define BME_SDA 21                      // Pin Define BME280 and GY21
#define SEALEVELPRESSURE_HPA (1013.25) // Sets the sealevel pressure
#define BUTTON 12                     // Pin Define for a Button to set the scale to Tare

Adafruit_BME280 bme; // I2C BME 280
SHT21 SHT21;        // selecting SHT21 as sensor for second temperature

#define SerialMon Serial
#define RX2 16                                       // Pin Define für GSM Modul SIM800L
#define TX2 17                                      // Pin Define für GSM Modul SIM800L
#define SerialAT Serial2                           //Define Serial2 for communication with SIM800L
#define TINY_GSM_RX_BUFFER 1024                   // Buffer for receiving SMS
#define TINY_GSM_DEBUG SerialMon                 //prints debug info to serial monitor
#define GSM_PIN ""                              // enter GSM Pin here, but this option is very beta so better deactivate the PIN of the SIM-Card
String handy = "AT+CMGS=\"+49123456789\"";   // String for cell phone number to send alarm SMS
String test;
lv_obj_t *ta;

String gsm_stringOne, gsm_stringTwo, gsm_stringThree;   // Strings for constructing the AT cellphone number command

const int relaisPin = 13;    //Pin Define relais 5 Volt hx711 + bme280 + HT
const int relaisPin1 = 15;  //Pin Define relais 4.1 Volt Sim800L
const int relaisPin2 = 14; //Pin Define relais 3.3V hx711



const int LOADCELL_DOUT_PIN = 35; // Define for HX711 Scale Pins   
const int LOADCELL_SCK_PIN = 32; // Define for HX711 Scale Pins   
int buttonState = 0;            // Define for tara button
bool buttonPressed = false;    // Define for state of tara button
HX711 scale;                  // setting HX711 as scale
Preferences preferences;     // Methode for saving Tare Results
unsigned long delayTime;    // delay time for HX711

const int wdtTimeout = 60000;  //time in ms to trigger the watchdog
hw_timer_t *timer = NULL;

/*variables for saving data in rtc memory for surviving deep sleep mode( non rtc variables are deleted on wake up)*/

RTC_DATA_ATTR int BootCounter = 0;      // defines variable for startcounter 
RTC_DATA_ATTR int i = 0;                // Counter for GUI operating mode so the gui related setup is only called once
RTC_DATA_ATTR float Tare;               // defines variable for tare value
RTC_DATA_ATTR float gewicht;            // defines variable for weight
RTC_DATA_ATTR float temperatur;         // defines variable for enviroment measurement
RTC_DATA_ATTR float luftdruck;          // defines variable for enviroment measurement
RTC_DATA_ATTR float luftfeuchtigkeit;   // defines variable for humidty
RTC_DATA_ATTR float gtemperatur;        // defines variable for case temperature
RTC_DATA_ATTR int durchlaeufe = 0;      // defines variable for the measure/upload cycle
RTC_DATA_ATTR bool abschwaerm = false;  // defines variable for abschwaerm alarm 
RTC_DATA_ATTR float gewichtalt = 0;     // defines variable for the weight needed to calcute the abschwaerm alarm properly
RTC_DATA_ATTR String stringHandy;       // defines variable for cellphone number


/*display related settings that need to be set before setup*/
    Ticker tick;                                    //timer for interrupt handler
    TFT_eSPI tft = TFT_eSPI();                      //TFT instance 
    static lv_disp_buf_t disp_buf;
    static lv_color_t buf[LV_HOR_RES_MAX * 10];
    static void create_tab1(lv_obj_t * parent);
    static void create_tab2(lv_obj_t * parent);
    static void create_tab3(lv_obj_t * parent);
    lv_obj_t * slider_label;
    int screenWidth = 480;
    int screenHeight = 320;
    #define LVGL_TICK_PERIOD 60




/*Function to reboot(or send to deep sleep) ESP32 through Watchdog*/
    
void IRAM_ATTR resetModule()  
{
  //ets_printf("reboot durch watchdog\n");                          
  //esp_restart();                                      //alternative mode to reboot after watchdog instead of going to deep sleep
  ets_printf("Beginne Deep Sleep \n");                 // Message printed in Serial Monitor
  durchlaeufe = 0;                                    // set the counter for measure/upload cycle back to 0
  i = 0;
  abschwaerm = false;
  esp_sleep_enable_timer_wakeup(SleepTime * ConversionSeconds);    // Setting time for deep sleep
  esp_deep_sleep_start();                                         // Starts Deep Sleep
}

/* function for reading AT responsen in serial monitor while debugging*/

void updateSerialMon()
{
  delay(500);
  while (Serial.available()) 
  {
    SerialAT.write(SerialMon.read());//Forward what Serial received to Software Serial Port
  }
  while(SerialAT.available()) 
  {
    SerialMon.write(SerialAT.read());//Forward what Software Serial received to Serial Port
  }
}


/* settings for the watchdog */

void configureWatchdog()
{
  timer = timerBegin(0, 80, true);                  //timer 0, div 80
  timerAttachInterrupt(timer, &resetModule, true);  //attach callback
  timerAlarmWrite(timer, wdtTimeout * 1000, false); //set time in us
  timerAlarmEnable(timer);                          //enable interrupt
}





/*method to print the wakeup reason in serial monitor for debugging purposes*/

 void print_wakeup_reason()
 {
  esp_sleep_wakeup_cause_t wakeup_reason;
 
  wakeup_reason = esp_sleep_get_wakeup_cause();
 
 
 
  switch(wakeup_reason)
  {
    case ESP_SLEEP_WAKEUP_EXT0 : Serial.println("Wakeup caused by external signal using RTC_IO"); break;
    case ESP_SLEEP_WAKEUP_EXT1 : Serial.println("Wakeup caused by external signal using RTC_CNTL"); break;
    case ESP_SLEEP_WAKEUP_TIMER : Serial.println("Wakeup caused by timer"); break;
    case ESP_SLEEP_WAKEUP_TOUCHPAD : Serial.println("Wakeup caused by touchpad"); Touch = true; break;   // sets touch to true if woken up via GPIO
    case ESP_SLEEP_WAKEUP_ULP : Serial.println("Wakeup caused by ULP program"); break;
    default : Serial.printf("Wakeup was not caused by deep sleep: %d\n",wakeup_reason); break;
  }
}
 
/*
Method to print the touchpad by which the ESP32 has been awaken from sleep
*/
void print_wakeup_touchpad()
{
  touch_pad_t pin;
 
  touchPin = esp_sleep_get_touchpad_wakeup_status();
 
  switch(touchPin)
  {
    case 0  : Serial.println("Touch detected on GPIO 4"); break;
    case 1  : Serial.println("Touch detected on GPIO 0"); break;
    case 2  : Serial.println("Touch detected on GPIO 2"); break;
    case 3  : Serial.println("Touch detected on GPIO 15"); break;
    case 4  : Serial.println("Touch detected on GPIO 13"); break;
    case 5  : Serial.println("Touch detected on GPIO 12"); break;
    case 6  : Serial.println("Touch detected on GPIO 14"); break;
    case 7  : Serial.println("Touch detected on GPIO 27"); break;
    case 8  : Serial.println("Touch detected on GPIO 33"); break;
    case 9  : Serial.println("Touch detected on GPIO 32"); break;
    default : Serial.println("Wakeup not by touchpad"); break;
  }
}
 

void setup()
{
  esp_sleep_wakeup_cause_t wakeup_cause; // Variable für wakeup Ursache
  configureWatchdog();
  pinMode (relaisPin, OUTPUT);      //switching relais on for 3.3V power (Display + Touch, HX711 Scale, BME Sensor)
  digitalWrite (relaisPin, HIGH); 
  delay(500);//switching relais on for 3.3V power (Display + Touch, HX711 Scale, BME Sensor)
  pinMode (relaisPin2, OUTPUT);     //switching relais on for 4.1V power (SIM800l GSM Modul)  
  digitalWrite (relaisPin2, HIGH);    //switching relais on for 4.1V power (SIM800l GSM Modul)
  delay(500);
  pinMode(BUTTON, INPUT_PULLUP);       // define mode for tara button
  delay(500);
  Serial.begin(115200);             // starting serial monitor
  delay(500);
  Serial.println("Relais online...starting setup()");
  delay(500);
  ++BootCounter;
  Serial.println("Start Nr.: " + String(BootCounter));
  //Print the wakeup reason for ESP32 and touchpad too
  print_wakeup_reason();
  print_wakeup_touchpad();
  //Setup interrupt on Touch Pad 7 (GPIO27)
  touchAttachInterrupt(T7, callback, Threshold);
  Serial.println("1"); 


  //Configure Touchpad as wakeup source
  esp_sleep_enable_touchpad_wakeup();
  wakeup_cause = esp_sleep_get_wakeup_cause(); // fetch wakeup reason
  Serial.println("Setup done");
  
}

void callback(){
  //placeholder callback function...do not delete!
}
 
void loop()
{
  
 /*
here we separate between the 2 modes the bienomat is working in. first mode is wakeup by touch, second mode is wakeup by timer
*/
  while (Touch == true){
   
    if (i == 0)        // on the first round(i=0)through the while all setup related things are set, after i>0 just the else is repeated
    {
         Serial.println("Display AN");
         pinMode (4, OUTPUT);
         digitalWrite (4, HIGH);
         Serial.println("Beginn Display setup");
    
         // starting setup for displaymode
        lv_disp_buf_init(&disp_buf, buf, NULL, LV_HOR_RES_MAX * 10);
        ledcSetup(10, 5000/*freq*/, 10 /*resolution*/);
        ledcAttachPin(32, 10);
        analogReadResolution(10);
        ledcWrite(10,768);
        
        // Conversion of variables for displaying them with the GUI  
        #define MAX_STRING_SIZE 7
        char gewicht_gui[5];
        snprintf(gewicht_gui, 5, "%f", gewicht);
        char temperatur_gui[6];
        snprintf(temperatur_gui, 6, "%f", temperatur, 3);
        char luftfeuchitgkeit_gui[6];
        snprintf(luftfeuchitgkeit_gui, 6, "%f", luftfeuchtigkeit);
        char luftdruck_gui[MAX_STRING_SIZE];
        snprintf(luftdruck_gui, MAX_STRING_SIZE, "%f", luftdruck);
    
  
            lv_init();
          
            #if USE_LV_LOG != 0
              lv_log_register_print(my_print); /* register print function for debugging */
            #endif
            tft.begin(); /* TFT init */
            tft.setRotation(1);
          
            uint16_t calData[5] = { 275, 3620, 264, 3532, 1 };
            tft.setTouch(calData);
            
            /*Initialize the display*/
            lv_disp_drv_t disp_drv;
            lv_disp_drv_init(&disp_drv);
            disp_drv.hor_res = 320;
            disp_drv.ver_res = 240;
            disp_drv.flush_cb = my_disp_flush;
            disp_drv.buffer = &disp_buf;
            lv_disp_drv_register(&disp_drv);
          
          
            lv_indev_drv_t indev_drv;
            lv_indev_drv_init(&indev_drv);             /*Descriptor of a input device driver*/
            indev_drv.type = LV_INDEV_TYPE_POINTER;    /*Touch pad is a pointer-like device*/
            indev_drv.read_cb = my_touchpad_read;      /*Set your driver function*/
            lv_indev_drv_register(&indev_drv);         /*Finally register the driver*/
            
          
          
            //Initialize the graphics library's tick
            
            tick.attach_ms(LVGL_TICK_PERIOD, lv_tick_handler);
          
            //Set the theme..
            lv_theme_t * th = lv_theme_material_init(210, NULL);     //Set a HUE value and a Font for the Night Theme
            lv_theme_set_current(th);
          
            lv_obj_t * scr = lv_cont_create(NULL, NULL);
            lv_disp_load_scr(scr);






    
                      //Creating a Tab view object with 3 pages
                      lv_obj_t *tabview;
                      tabview = lv_tabview_create(lv_scr_act(), NULL);
                  
                      /*Add 3 tabs (the tabs are page (lv_page) and can be scrolled*/
                      lv_obj_t *tab1 = lv_tabview_add_tab(tabview, "Uebersicht");
                      lv_obj_t *tab2 = lv_tabview_add_tab(tabview, "Visualisierung");
                      lv_obj_t *tab3 = lv_tabview_add_tab(tabview, "Einstellungen");
                  
                      /*Add content to the tabs*/
                      lv_obj_t * label = lv_label_create(tab1, NULL);
                      lv_label_set_text(label, "");
                      label = lv_label_create(tab2, NULL);
                      lv_label_set_text(label, "");
                     
                      //////////////////////////////////////////////////////
                      //Content of TAB1
                      ////////////////////////////////////////////////////
                  
                                              
                      //Creating a cell for tab1
                      static lv_style_t style_cell1;
                      lv_style_copy(&style_cell1, &lv_style_plain);
                      style_cell1.body.border.width = 2;
                      style_cell1.body.border.color = LV_COLOR_BLACK;
                  
                      /*Crealte a header cell style*/
                      static lv_style_t style_cell2;
                      lv_style_copy(&style_cell2, &lv_style_plain);
                      style_cell2.body.border.width = 2;
                      style_cell2.body.border.color = LV_COLOR_BLACK;
                      style_cell2.body.main_color = LV_COLOR_SILVER;
                      style_cell2.body.grad_color = LV_COLOR_SILVER;
                  
                      lv_obj_t * table = lv_table_create(tab1, NULL);
                      lv_table_set_style(table, LV_TABLE_STYLE_CELL1, &style_cell1);
                      lv_table_set_style(table, LV_TABLE_STYLE_CELL2, &style_cell2);
                      lv_table_set_style(table, LV_TABLE_STYLE_BG, &lv_style_transp_tight);
                      lv_table_set_col_cnt(table, 3);
                      lv_table_set_row_cnt(table, 5);
                      lv_obj_align(table, NULL, LV_ALIGN_CENTER, -14, 0);
                  
                      //Make the cells of the first row center aligned
                      lv_table_set_cell_align(table, 0, 0, LV_LABEL_ALIGN_CENTER);
                      lv_table_set_cell_align(table, 0, 1, LV_LABEL_ALIGN_CENTER);
                      lv_table_set_cell_align(table, 0, 2, LV_LABEL_ALIGN_CENTER);
                      
                      //Make the cells of the first row TYPE = 2 (use `style_cell2`) so we have a nice table
                      lv_table_set_cell_type(table, 0, 0, 2);
                      lv_table_set_cell_type(table, 0, 1, 2);
                      lv_table_set_cell_type(table, 0, 2, 2);
                      
                      
                      
                      // Content of the first column
                      lv_table_set_cell_value(table, 0, 0, "Sensor");
                      lv_table_set_cell_value(table, 1, 0, "Gewicht:" );
                      lv_table_set_cell_value(table, 2, 0, "Temperatur:");
                      lv_table_set_cell_value(table, 3, 0, "Luftfeuchtigkeit:");
                      lv_table_set_cell_value(table, 4, 0, "Luftdruck:");
                      // Content of the second column
                      lv_table_set_cell_value(table, 0, 1, "Wert");
                      lv_table_set_cell_value(table, 1, 1, gewicht_gui );
                      lv_table_set_cell_value(table, 2, 1, temperatur_gui);
                      lv_table_set_cell_value(table, 3, 1, luftfeuchitgkeit_gui);
                      lv_table_set_cell_value(table, 4, 1, luftdruck_gui);
                      // Content of the third column
                      lv_table_set_cell_value(table, 0, 2, "Einheit");
                      lv_table_set_cell_value(table, 1, 2, "kg");
                      lv_table_set_cell_value(table, 2, 2, "* C");
                      lv_table_set_cell_value(table, 3, 2, "%");
                      lv_table_set_cell_value(table, 4, 2, "hPa");
                      //Width of cell
                      lv_table_set_col_width(table, 0, 130);
                      lv_table_set_col_width(table, 3, 50);
                      // Cell grows not with words
                      lv_table_set_cell_crop(table, 3, 0, true);
                      
                  
                      /////////////////////////////////////////////////////////////////
                      //CONTENT of TAB2
                      ////////////////////////////////////////////////////////////////
                  
                      lv_obj_t * label2 = lv_label_create(tab2, NULL);
                      lv_label_set_long_mode(label2, LV_LABEL_LONG_SROLL_CIRC);     //setting mode of circle
                      lv_obj_set_width(label2, 200);
                      lv_label_set_text(label2, "Visualisierung der letzten Gewichtsmessung in Kilogramm             ");  // Content of the label
                      lv_obj_align(label2, NULL, LV_ALIGN_CENTER, 0, 80);
                  
                  
                     /*Create a style*/
                      static lv_style_t style;
                      lv_style_copy(&style, &lv_style_pretty_color);
                      style.body.main_color = lv_color_hex3(0x666);     /*Line color at the beginning*/
                      style.body.grad_color =  lv_color_hex3(0x666);    /*Line color at the end*/
                      style.body.padding.left = 10;                      /*Scale line length*/
                      style.body.padding.inner = 8 ;                    /*Scale label padding*/
                      style.body.border.color = lv_color_hex3(0x333);   /*Needle middle circle color*/
                      style.line.width = 3;
                      style.text.color = lv_color_hex3(0x333);
                      style.line.color = LV_COLOR_RED;                  /*Line color after the critical value*/
                  
                      /*Describe the color for the needles*/
                      static lv_color_t needle_colors[] = {LV_COLOR_BLUE, LV_COLOR_ORANGE, LV_COLOR_PURPLE};
                  
                      /*Create a gauge*/
                      lv_obj_t * gauge1 = lv_gauge_create(tab2, NULL);
                      lv_gauge_set_style(gauge1, LV_GAUGE_STYLE_MAIN, &style);
                      lv_gauge_set_needle_count(gauge1, 1, needle_colors);
                      lv_obj_set_size(gauge1, 200, 200);
                      lv_obj_align(gauge1, NULL, LV_ALIGN_CENTER, 0, 20);
                  
                      /*Set the values*/
                      lv_gauge_set_value(gauge1, 0, gewicht);
                      // lv_gauge_set_value(gauge1, 1, 20);
                      //lv_gauge_set_value(gauge1, 2, 30);
                  
                  
                      /////////////////////////////////////////////////////////////////////////////////
                      // CONTENT OF TAB3
                      ////////////////////////////////////////////////////////////////////////////
                      label = lv_label_create(tab3, NULL);                    
                      lv_label_set_text(label, "");
                      
                      lv_obj_t * btn1 = lv_btn_create(tab3, NULL);
                      lv_obj_set_event_cb(btn1, sleepevent_handler);
                      lv_obj_align(btn1, NULL, LV_ALIGN_IN_RIGHT_MID, 0, 12);
                      label = lv_label_create(btn1, NULL);
                      lv_label_set_text(label, "Deep Sleep");
                  
                      lv_obj_t * btn2 = lv_btn_create(tab3, NULL);
                      lv_obj_set_event_cb(btn2, dbevent_handler);
                      lv_obj_align(btn2, NULL, LV_ALIGN_IN_LEFT_MID, -5, 12);
                      label = lv_label_create(btn2, NULL);
                      lv_label_set_text(label, "DB-Upload");
                  
                      lv_obj_t * btn3 = lv_btn_create(tab3, NULL);
                      lv_obj_set_event_cb(btn3, handyevent_handler);
                      lv_obj_align(btn3, NULL, LV_ALIGN_CENTER, 0, 12);
                      label = lv_label_create(btn3, NULL);
                      lv_label_set_text(label, "Handy Nr.");

    } //end if

    
     
     else   // after setting all setup related things the gui will just refresh 
        Serial.println(millis());
        while (millis() < 240000)
        {
        lv_task_handler(); /* let the GUI do its work */
        delay(5);
        timerWrite(timer, 0); //reset timer (feed watchdog)
        ++i;
        }
        resetModule();
        
        
      
    } //End While touch=true

  /* in this part of the loop there happens the magic for the second operating mode (wakeup by timer or reboot) */
  
  Serial.println("Starte Funktionen"); 
  
  delay(500);
  klima();      // calling temprature and humidity and pressure function
  button();     // calling tare button function
  wiegen();     // calling weight function
  ++ durchlaeufe;
      if (durchlaeufe == 1)     // if the bienomat has started 4 times this will call the database upload
      {
       datenbank();  // calling wifi login + database-upload function
       durchlaeufe = 0; // set the counter back to 0
      }
  Serial.println("Entering Deepsleepmode \r\n \r\n");   
  Serial.println("Good night sweet prince :* \r\n \r\n");
  digitalWrite (relaisPin, LOW);
  delay(500);
  digitalWrite (relaisPin1, LOW);
  delay(500);
  digitalWrite (relaisPin2, LOW);
  Serial.println("Relais offline");
  Serial.println("Deep Sleep - Gehe schlafen \r\n \r\n");  
  Serial.println("Gute Nacht :* \r\n \r\n");
  esp_sleep_enable_timer_wakeup(SleepTime * ConversionSeconds);    // Deep Sleep Zeit einstellen
  esp_deep_sleep_start();                       // Starte Deep Sleep
  
} // END OF LOOP


//function for measuring the weight on the scale
 void wiegen()
{ 
  
  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);  // beginig scale hx711 connection with pins from define
  Serial.println("2");
  scale.set_scale(28633.1136);                        // Scalefactor of the scale
  Serial.println("3");
  delayTime = 1000;
  scale.power_up(); //HX711 ADC booting
  Serial.print("Einzelablesung:\t");
  Serial.print(scale.get_units());    // reading actual wieght without tare result
  preferences.begin("Tara", false);   // opening a folder for saving and writing tara
  Tare = preferences.getFloat("TaraGewicht", 0);  // den Geschützten Wert aufrufen und in der Variablen Tare speichern
  gewicht = (scale.get_units(10));   // save the average from 10 meassurements
  gewicht = (gewicht - Tare);        // calculate actual weight  
  Serial.print(gewicht, 1);         // printing result 
  Serial.print("\t| Schnitt:\t");
  Serial.print(gewicht, 2);         // printing result 
  Serial.print("\t| Schnitt:\t");
  Serial.println(gewicht, 3);       // printing result 
  preferences.end();                // close folder
  scale.power_down();             // put the ADC in sleep mode
  
    if (gewicht < 0)        // if the result saved in gewicht is to low the alert sms function will be called
    {
      sms_weight ();
    }
  
    if (gewicht < (gewichtalt -2.0) && gewicht > 0)        // if the result saved in gewicht is to low the alert sms function will be called
    {
      abschwaerm = true;
      sms_weight ();
    }
    gewichtalt = gewicht;
    
    /*preferences.begin("messung", false);   // open folder on esp to save tare value to be reset safe
    preferences.putFloat("AltesGewicht", gewichtalt);    // saving tare value
    preferences.end();   // closing folder*/
    
  
  
}                   //end void wiegen

//function for setting the scale to 0 aka Tara
void button ()
{
  scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);  // beginig scale hx711 connection with pins from define
  Serial.println("2");
  scale.set_scale(28633.1136);                        // Scalefactor of the scale
  Serial.println("3");
  delayTime = 1000;
  Serial.println("Bitte drücken Sie den Tara knopf für 5 sekunden");
  delay(500);  
  buttonState = digitalRead(BUTTON); //reads state of button
  delay(100);
  Serial.println(buttonState);  // print zero if button is pressed
      if (buttonState == LOW)
        {
          Tare = (scale.get_units(10)); // saves average from 10 measurements
          Serial.println(Tare);         // tells the value auf tare
          preferences.begin("Tara", false);   // open folder on esp to save tare value to be reset safe
          preferences.putFloat("TaraGewicht", Tare);    // saving tare value
          preferences.end();   // closing folder
          scale.power_down();             // put the ADC in sleep mode
        }
}                            //end void button


// this function will send the alarm sms
void sms_weight ()
{
  pinMode (relaisPin1, OUTPUT);     //switching relais on for 4.1V power (HX711 Scale)
  digitalWrite (relaisPin1, HIGH);    //switching relais on for 4.1V power (HX711 Scale)
  delay(3000);   //delay for making sure gsm is connected

  
  Serial.println("Initializing...SIM800L GSM Modul"); 
  
  SerialAT.begin(9600, SERIAL_8N1);
  delay(4000);
  SerialAT.println("AT"); //Once the handshake test is successful, it will back to OK
  updateSerialMon();
  delay(5000);
  SerialAT.println("AT+CSQ"); // Will return the signal strength
  updateSerialMon();
  
  SerialAT.println("AT+CREG?"); //will return info if connected or not
  updateSerialMon();
  SerialAT.println("AT+COPS?"); // will return info about carrier
  updateSerialMon();
  SerialAT.println("AT+CMGF=1"); // Configuring TEXT mode
  updateSerialMon();
  preferences.begin("Handy", false);   // opening a folder for saving and writing tara
  stringHandy = preferences.getString("Handynr");  // den Geschützten Wert aufrufen und in der Variablen Tare speichern
  SerialAT.println(stringHandy); // calling string with variable for cell number
  
  
    if (abschwaerm == true)
      {
       SerialAT.println("Fang die Bienen wieder ein Junge"); //text content abschwaermen
       updateSerialMon();
       SerialAT.write(26);
       abschwaerm = false;
      }// end if
  
    else 
      {
         SerialAT.println("Alles ist weg und kaputt"); //text content windwurf
         updateSerialMon();
         SerialAT.write(26);
      } // end else
  
  
  delay(10000);
  preferences.end();                // close folder
  digitalWrite (relaisPin1, LOW);    //switching relais on for 4.1V power (GSM)
}


//this function reads all climate sensors and save the values
void klima ()
{
  bool status;
  status = bme.begin(0x76);
      if (!status)
       {
        delay(500);                                                                   // if there is a problem with the bme sensor the watch will kick in cause of the delay
        Serial.println("Could not find a valid BME280 sensor, check wiring!");  
        while (1);
       }
  Serial.println();
  temperatur = bme.readTemperature();         //define variables for enviroment measurement
  luftdruck = bme.readPressure() / 100.0F;    //define variables for enviroment measurement
  luftfeuchtigkeit = bme.readHumidity();      //define variables for enviroment measurement
  gtemperatur = (SHT21.getTemperature());     //define variables for enviroment measurement

  Serial.print("Temperature = ");
  Serial.print(temperatur);
  Serial.println(" °C");

  Serial.print("Pressure = ");
  Serial.print(luftdruck);
  Serial.println(" hPa");

  Serial.print("Humidity = ");
  Serial.print(luftfeuchtigkeit);
  Serial.println(" %");

 
  Serial.print("Case Temperature = ");
  Serial.print(gtemperatur);
  Serial.println(" *C");
  Serial.println();
  delay(500);
  Serial.print("void_klima beendet");

}


// this function will establish a WiFI connection and transfer the data to the TBS1 server
void datenbank ()

{
  
  Serial.println("Aufbau WIFI Verbindung zur Datenuebertragung");
  WiFi.mode(WIFI_STA);
  WiFi.begin("APN", "12345678");   // wifi credentials 


  
    while (WiFi.status() != WL_CONNECTED) // if no wifi connection delay is called so after some time the watchdog kicks in to save battery time
      {
        delay(500);
        Serial.println(".");
      }
  
  
  
  
  Serial.println("WIFI Verbunden");
  Serial.print("IP Addresse: ");
  Serial.println(WiFi.localIP());
                  
    HTTPClient http;                                                        //starting to put the url together for calling the writemysql script on Server
    delay(5);
    String url;
    url += "https://yourserver.de/writemysql.php?temp=";                    // put your server url here like formatted in example
    url += String(temperatur);
    url += "&luftd=";
    url += String(luftdruck);
    url += "&luftf=";
    url += String(luftfeuchtigkeit);
    url += "&gewi=";
    url += String(gewicht);
    url += "&gtemp=";
    url += String(gtemperatur);
    http.begin(url);
    delay(5);
    http.GET();
    delay(5);
    http.end();
    delay(5);
    Serial.print("Daten gesendet");
    delay(700);
    WiFi.disconnect(true);              //disconnect from AP
    WiFi.mode(WIFI_OFF);              //End wifimode
    delay(500);
    Serial.print("void_datenbank beendet");
  
  }
  
//Display flushing 
void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p)
{
  uint16_t c;

  tft.startWrite(); /* Start new TFT transaction */
  tft.setAddrWindow(area->x1, area->y1, (area->x2 - area->x1 + 1), (area->y2 - area->y1 + 1)); /* set the working window */
  for (int y = area->y1; y <= area->y2; y++) {
    for (int x = area->x1; x <= area->x2; x++) {
      c = color_p->full;
      tft.writeColor(c, 1);
      color_p++;
    }
  }
  tft.endWrite(); /* terminate TFT transaction */
  lv_disp_flush_ready(disp); /* tell lvgl that flushing is done */
}



//interrupt driven periodic handler for the GUI
static void lv_tick_handler(void)
{

  lv_tick_inc(LVGL_TICK_PERIOD);
}



//Function returning the place where touch is applied on screen...needed for debugging
bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data)
{
    uint16_t touchX, touchY;

    bool touched = tft.getTouch(&touchX, &touchY, 600);

    if(!touched)
    {
      return false;
    }

    if(touchX>screenWidth || touchY > screenHeight)
    {
      Serial.println("Y or y outside of expected parameters..");
      Serial.print("y:");
      Serial.print(touchX);
      Serial.print(" x:");
      Serial.print(touchY);
    }
    else
    {

      data->state = touched ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL; 
  
      /*Save the state and save the pressed coordinate*/
      //if(data->state == LV_INDEV_STATE_PR) touchpad_get_xy(&last_x, &last_y);
     
      /*Set the coordinates (if released use the last pressed coordinates)*/
      data->point.x = touchX;
      data->point.y = touchY;
  
      Serial.print("Data x");
      Serial.println(touchX);
      
      Serial.print("Data y");
      Serial.println(touchY);

    }

    return false; /*Return `false` because we are not buffering and no more data to read*/
}

//events for GUI
void slider_event_cb(lv_obj_t * slider, lv_event_t event)
{

  

  if(event == LV_EVENT_VALUE_CHANGED) {
      static char buf[4];                                 /* max 3 bytes  for number plus 1 null terminating byte */
      snprintf(buf, 4, "%u", lv_slider_get_value(slider));
      lv_label_set_text(slider_label, buf);               /*Refresh the text*/
  }
}

static void btn_event_cb(lv_obj_t * btn, lv_event_t event)
{
    if(event == LV_EVENT_RELEASED) {
        /*Increase the button width*/
        lv_coord_t width = lv_obj_get_width(btn);
        lv_obj_set_width(btn, width - 20);
    }
}



static void sleepevent_handler(lv_obj_t * btn1, lv_event_t event)
{
    if(event == LV_EVENT_CLICKED) {
        printf("Clicked\n");
          printf("Test1\n");                
          Serial.println("Entering Deepsleepmode \r\n \r\n");   
        Serial.println("Good night sweet prince :* \r\n \r\n");
        digitalWrite (relaisPin, LOW);
        delay(500);
        digitalWrite (relaisPin1, LOW);
        delay(500);
        digitalWrite (relaisPin2, LOW);
        digitalWrite (4, LOW);
        i = 0;
        Serial.println("Relais off off");
        esp_sleep_enable_timer_wakeup(SleepTime * ConversionSeconds);    // Deep Sleep Zeit einstellen
        esp_deep_sleep_start();                       // Starte Deep Sleep  
    }
    else if(event == LV_EVENT_VALUE_CHANGED) {
        printf("Toggled\n");
    }
}


static void dbevent_handler(lv_obj_t * btn2, lv_event_t event)
{
    if(event == LV_EVENT_CLICKED) {
        printf("Clicked\n");
                   printf("Test3\n");        // Starte Deep Sleep
                   datenbank();
    }
    else if(event == LV_EVENT_VALUE_CHANGED) {
        printf("Toggled\n");
    }
}


static void handyevent_handler(lv_obj_t * btn3, lv_event_t event)
{
    if(event == LV_EVENT_CLICKED) {
        printf("Clicked\n");
                   printf("Test2\n");        // Starte Deep Sleep
                    /*Create styles for the keyboard*/
    static lv_style_t rel_style, pr_style;

    lv_style_copy(&rel_style, &lv_style_btn_rel);
    rel_style.body.radius = 0;
    rel_style.body.border.width = 1;

    lv_style_copy(&pr_style, &lv_style_btn_pr);
    pr_style.body.radius = 0;
    pr_style.body.border.width = 1;

    /*Create a keyboard and apply the styles*/
    lv_obj_t *kb = lv_kb_create(lv_scr_act(), NULL);
    lv_kb_set_mode(kb, LV_KB_MODE_NUM); 
    lv_obj_set_event_cb(kb, keyboard_event_cb);
    lv_kb_set_cursor_manage(kb, true);
    lv_kb_set_style(kb, LV_KB_STYLE_BG, &lv_style_transp_tight);
    lv_kb_set_style(kb, LV_KB_STYLE_BTN_REL, &rel_style);
    lv_kb_set_style(kb, LV_KB_STYLE_BTN_PR, &pr_style);

    /*Create a text area. The keyboard will write here*/
    ta = lv_ta_create(lv_scr_act(), NULL);
    lv_obj_align(ta, NULL, LV_ALIGN_IN_TOP_MID, 0, 10);

   
    lv_ta_set_text(ta,"");
   
    
    lv_obj_set_event_cb(ta, keyboard_event_cb);

    /*Assign the text area to the keyboard*/
    lv_kb_set_ta(kb, ta);

    printf("%s\n", lv_ta_get_text(ta));
    
    }
    else if(event == LV_EVENT_VALUE_CHANGED) {
        printf("Toggled\n");
    }
}



/*

 * Called when the close or ok button is pressed on the keyboard

 */

 
static void keyboard_event_cb(lv_obj_t * kb, lv_event_t event)
{
    lv_kb_def_event_cb(kb, event);

    if(event == LV_EVENT_APPLY)
      { 
        
        printf("%s\n", lv_ta_get_text(ta));
        gsm_stringOne = String("AT+CMGS=\"");
        gsm_stringTwo = lv_ta_get_text(ta);
        printf("%s\n", gsm_stringTwo);
        gsm_stringThree = String("\"");
        stringHandy = gsm_stringOne + gsm_stringTwo + gsm_stringThree;
        Serial.println(stringHandy);
        
          preferences.begin("Handy", false);   // open folder on esp to save tare value to be reset safe
          preferences.putString("Handynr", stringHandy);    // saving tare value
          preferences.end();   // closing folder
        
        //printf("%s\n", test);
        printf("keyboard event apply \n");
        lv_obj_del(kb);
        kb = NULL;
        lv_obj_del(ta);
        ta = NULL;
        
        

     }
    
    if(event == LV_EVENT_CANCEL)
    {
      lv_obj_del(kb);
      kb = NULL;
      lv_obj_del(ta);
      ta = NULL;
      printf("keyboard event cancel \n");
    }
    
}

// prints the events on the serial monitor
void printEvent(String Event, lv_event_t event)
{
  
  Serial.print(Event);
  printf(" ");

  switch(event) {
      case LV_EVENT_PRESSED:
          printf("Pressed\n");
          break;

      case LV_EVENT_SHORT_CLICKED:
          printf("Short clicked\n");
          break;

      case LV_EVENT_CLICKED:
          printf("Clicked\n");
          
          break;

      case LV_EVENT_LONG_PRESSED:
          printf("Long press\n");
          break;

      case LV_EVENT_LONG_PRESSED_REPEAT:
          printf("Long press repeat\n");
          break;

      case LV_EVENT_RELEASED:
          printf("Released\n");
          break;
  }
}
